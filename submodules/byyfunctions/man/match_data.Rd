% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/match_data.R
\name{match_data}
\alias{match_data}
\title{Match data by date of entry}
\usage{
match_data(
  .data,
  ref_col,
  match_col,
  select_col,
  group_col = "RID",
  max_diff = NULL,
  match_df = NULL,
  include_idx = FALSE
)
}
\arguments{
\item{.data}{dataframe containing the reference data and matching data}

\item{ref_col}{name of column to serve as reference value to match to}

\item{match_col}{name of column to get values to match}

\item{select_col}{names of column(s) to pull additional data from matched rows}

\item{group_col}{name of subject identifier column ("RID" for ADNI, "Subject" for
OASIS)}

\item{max_diff}{(optional) the maximum allowed time difference for a valid match;
if no entires fall within this allowed time difference, NA will be matched}

\item{match_df}{(optional) a separate dataframe or tibble from which matched data
will be pulled from. If specified, then \code{match_col} and \code{select_col} will be
pulled from \code{match_df}. If not specified, then the aforementioned columns
are pulled from \code{.data}}

\item{include_idx}{(optional) if TRUE, then includes an additional column which
has the global index of the matched row for each reference value; note that
this index will be incorrect once the output dataframe is filtered}
}
\value{
.data with additional columns containing matched data
}
\description{
Match a recorded data point to another recorded data point that is closest
in time to it
}
\details{
For example, match the CDR value closest in time to each subject's
PET scan. Each row containing non-NA data in the reference column will be
matched with a row containins non-NA data in the matching column which is closest
in value to the reference value. User may also specify additional columns to pull
data from the matched rows.
}
\section{Notes}{

When using dplyr::group_by, all subsequent functions on a dataframe
are performed per group. For our purposes, since we want to find the row index
corresponding to the matched entry for each reference value, the returned
index is of the group dataframe rather than the entire dataframe, which is not
the desired result. To combat this, we make a new column which indicates the
global index; that way, our matching function can reference this column and
return the global index rather than the group-wise index
}

